<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Gossip Metrics Visualization</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.2.1"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <style>
    :root {
      color-scheme: light;
      --ink: #1b1f2a;
      --muted: #566073;
      --bg: #f7f5f1;
      --panel: #ffffff;
      --accent: #d36c2f;
      --accent-soft: rgba(211, 108, 47, 0.15);
    }

    body {
      margin: 0;
      font-family: "IBM Plex Serif", "Georgia", serif;
      background: radial-gradient(circle at top left, #fff8f0, #f2efe9 60%, #e8e4db 100%);
      color: var(--ink);
    }

    header {
      padding: 24px 32px 12px;
    }

    header h1 {
      margin: 0 0 6px;
      font-size: 28px;
      letter-spacing: 0.5px;
    }

    header p {
      margin: 0;
      color: var(--muted);
    }

    .controls {
      display: flex;
      gap: 12px;
      padding: 0 32px 20px;
      flex-wrap: wrap;
      align-items: center;
    }

    .controls label {
      font-size: 13px;
      color: var(--muted);
    }

    .controls select,
    .controls input,
    .controls button {
      font-family: "IBM Plex Sans", "Helvetica Neue", sans-serif;
      padding: 8px 10px;
      border: 1px solid #d5d1c9;
      border-radius: 6px;
      background: var(--panel);
      color: var(--ink);
    }

    .controls button {
      background: var(--accent);
      color: white;
      border: none;
      cursor: pointer;
    }


    .layout {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      padding: 0 32px 32px;
    }

    .panel {
      background: var(--panel);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 20px 40px rgba(27, 31, 42, 0.08);
    }

    canvas {
      width: 100% !important;
      height: 300px !important;
    }


    .legend {
      display: flex;
      gap: 12px;
      margin-top: 12px;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 12px;
    }

    .legend span {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--accent);
    }


    @media (max-width: 960px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Gossip Metrics Board</h1>
    <p>Live view of gossip delay and connection strength from the OTLP collector.</p>
  </header>

    <div class="controls">
      <div>
        <label for="windowSelect">Window</label><br>
        <select id="windowSelect">
          <option value="120000">Last 2 minutes</option>
          <option value="300000" selected>Last 5 minutes</option>
          <option value="600000">Last 10 minutes</option>
        </select>
      </div>
      <div>
        <label for="stepSelect">Step (ms)</label><br>
        <select id="stepSelect">
          <option value="2000">2000</option>
          <option value="5000" selected>5000</option>
          <option value="10000">10000</option>
        </select>
      </div>
      <div>
        <label for="refreshInput">Refresh (s)</label><br>
        <input id="refreshInput" type="number" value="5" min="2" />
      </div>
      <div>
        <label>&nbsp;</label><br>
        <button id="refreshButton">Refresh now</button>
      </div>
    </div>


  <section class="layout">
    <div class="panel">
      <h2>Gossip Delay Quantiles</h2>
      <canvas id="delayChart"></canvas>
      <div class="legend">
        <span><span class="dot"></span> Overall delay quantiles</span>
      </div>
    </div>
    <div class="panel">
      <h2>Raw Gossip Delay</h2>
      <canvas id="rawChart"></canvas>
      <div class="legend">
        <span><span class="dot"></span> Raw delay by node</span>
      </div>
    </div>
  </section>

  <script>
    const delayCtx = document.getElementById("delayChart").getContext("2d");
    const rawCtx = document.getElementById("rawChart").getContext("2d");
    const refreshInput = document.getElementById("refreshInput");
    const windowSelect = document.getElementById("windowSelect");
    const stepSelect = document.getElementById("stepSelect");
    const refreshButton = document.getElementById("refreshButton");

    const chartColors = {
      p25: "#d36c2f",
      p50: "#2f7ed8",
      p90: "#78b13f",
      p99: "#d95f5f"
    };

    const hiddenQuantiles = new Set();

    function zoomOptions() {
      return {
        zoom: {
          drag: {
            enabled: true,
            borderColor: "rgba(225,225,225,0.3)",
            borderWidth: 2,
            backgroundColor: "rgba(225,225,225,0.3)"
          },
          mode: "x",
          wheel: { enabled: false },
          pinch: { enabled: true }
        },
        pan: {
          enabled: true,
          mode: "x"
        }
      };
    }

    function createLineChart({ ctx, titleText, legend }) {
      return new Chart(ctx, {
        type: "line",
        data: {
          datasets: []
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          parsing: false,
          scales: {
            x: {
              type: "time",
              time: {
                unit: "minute"
              },
              title: { display: true, text: "Time" }
            },
            y: {
              title: { display: true, text: "Delay (ms)" },
              beginAtZero: true
            }
          },
          plugins: {
            title: {
              display: Boolean(titleText),
              text: titleText || ""
            },
            legend: legend || { position: "bottom" },
            zoom: zoomOptions()
          }
        }
      });
    }

    const delayChart = createLineChart({
      ctx: delayCtx,
      legend: {
        position: "bottom",
        onClick: (event, legendItem, legend) => {
          const index = legendItem.datasetIndex;
          const chart = legend.chart;
          const dataset = chart.data.datasets[index];
          dataset.hidden = !dataset.hidden;
          const key = dataset.label.toLowerCase();
          if (dataset.hidden) {
            hiddenQuantiles.add(key);
          } else {
            hiddenQuantiles.delete(key);
          }
          chart.update();
        }
      }
    });

    const rawChart = createLineChart({ ctx: rawCtx });


    function toEpoch(dateString) {
      return new Date(dateString).getTime();
    }

    function computeRange() {
      const windowMs = Number(windowSelect.value);
      const end = new Date();
      const start = new Date(end.getTime() - windowMs);
      return { start, end };
    }

    async function fetchSeries(metric, groupBy, agg) {
      const { start, end } = computeRange();
      const params = new URLSearchParams({
        metric,
        start: start.toISOString(),
        end: end.toISOString(),
        step: stepSelect.value,
        agg
      });
      if (groupBy) {
        params.set("group_by", groupBy);
      }
      const response = await fetch(`/api/series?${params.toString()}`);
      if (!response.ok) {
        throw new Error(`Series fetch failed: ${response.status}`);
      }
      return response.json();
    }

    function normalizeQuantileSeries(series) {
      const entry = series[0];
      if (!entry) {
        return [];
      }
      return entry.points.map((point) => ({
        x: toEpoch(point.ts),
        y: point.value
      }));
    }

    function renderDelayChart(quantileSeries) {
      const quantiles = ["p25", "p50", "p90", "p99"];

      const datasets = quantiles.map((quantile) => ({
        label: quantile.toUpperCase(),
        data: quantileSeries[quantile] || [],
        borderColor: chartColors[quantile],
        backgroundColor: chartColors[quantile],
        fill: false,
        tension: 0.1,
        borderWidth: 2,
        pointRadius: 4,
        hidden: hiddenQuantiles.has(quantile)
      }));

      delayChart.data.datasets = datasets;
      delayChart.update();
    }

    function normalizeNodeSeries(series) {
      return series.map((entry) => ({
        node: entry.labels.node || "unknown",
        points: entry.points.map((point) => ({
          x: toEpoch(point.ts),
          y: point.value
        }))
      }));
    }

    function renderRawChart(nodeSeries) {
      const palette = [
        "#d36c2f",
        "#2f7ed8",
        "#78b13f",
        "#d95f5f",
        "#7b60d1",
        "#2da6a1",
        "#b24a79",
        "#5a7a3b"
      ];

      const datasets = nodeSeries.map((entry, index) => ({
        label: entry.node,
        data: entry.points,
        backgroundColor: palette[index % palette.length],
        borderColor: palette[index % palette.length],
        fill: false,
        tension: 0.1,
        pointRadius: 3
      }));

      rawChart.data.datasets = datasets;
      rawChart.update();
    }

    async function refresh() {
      try {
        const quantiles = ["p25", "p50", "p90", "p99"];
        const quantileResponses = await Promise.all(
          quantiles.map((quantile) => fetchSeries("gossip_delay_ms", "", quantile))
        );

        const quantileSeries = {};
        quantileResponses.forEach((response, index) => {
          quantileSeries[quantiles[index]] = normalizeQuantileSeries(response.series || []);
        });
        renderDelayChart(quantileSeries);

        const rawResponse = await fetchSeries("gossip_delay_ms", "node", "avg");
        const nodeSeries = normalizeNodeSeries(rawResponse.series || []);
        renderRawChart(nodeSeries);
      } catch (error) {
        console.error(error.message);
      }
    }

    let refreshTimer = null;
    function scheduleRefresh() {
      if (refreshTimer) {
        clearInterval(refreshTimer);
      }
      const intervalMs = Math.max(2000, Number(refreshInput.value || 5) * 1000);
      refreshTimer = setInterval(refresh, intervalMs);
    }

    refreshButton.addEventListener("click", refresh);
    refreshInput.addEventListener("change", scheduleRefresh);
    windowSelect.addEventListener("change", refresh);
    stepSelect.addEventListener("change", refresh);

    refresh();
    scheduleRefresh();

    delayChart.canvas.addEventListener("dblclick", () => delayChart.resetZoom());
    rawChart.canvas.addEventListener("dblclick", () => rawChart.resetZoom());
  </script>
</body>
</html>
